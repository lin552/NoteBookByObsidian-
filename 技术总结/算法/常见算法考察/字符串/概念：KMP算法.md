---
创建时间: 2025-05-17 14:28:39
作者: wangxiaoming
tags:
  - String
  - 算法
---
#### 一、核心思想
`KMP（Knuth-Morris-Pratt` 算法的核心是**利用模式串自身的信息**，通过预处理生成`next`数组（部分匹配表），在匹配失败时跳过不必要的回溯，从而将时间复杂度从暴力法的 O(n×m) 优化到 O(n+m)。  
其核心理念是：​**当匹配失败时，模式串的指针不需要回退到起点，而是根据已匹配的部分信息，移动到可能的最长公共前后缀的下一个位置继续匹配**。

#### 二、关键概念：next数组
##### **1. `next`数组的定义**​

- `next[j]` 表示模式串 `P[0...j-1]` 的**最长相等前缀和后缀的长度**。
    - ​**前缀**​：不包含最后一个字符的连续子串（如 `ABCD` 的前缀是 `A`, `AB`, `ABC`）。
    - ​**后缀**​：不包含第一个字符的连续子串（如 `ABCD` 的后缀是 `BCD`, `CD`, `D`）。
- ​**示例**​：  
    模式串 `ABABCABAB` 的 `next` 数组为：
    - `next[5] = 0`：子串 `ABABC` 的最长公共前后缀长度为 0（无公共前后缀）。
    - `next[7] = 2`：子串 `ABABCA` 的最长公共前后缀是 `AB`（长度 2）。
```markdown
索引：0 1 2 3 4 5 6 7 8  
字符：A B A B C A B A B  
next：-1 0 0 1 2 0 1 2 3  
```
##### ​**2. `next`数组的构建逻辑**​

- ​**初始化**​：`next[0] = -1`（第一个字符无前缀）。
- ​**双指针法**​：
    - `i` 表示当前字符的索引，`j` 表示前缀的末尾索引。
    - 如果 `P[i] == P[j]`，则 `next[i+1] = j+1`，并同时移动 `i` 和 `j`。
    - 如果 `P[i] != P[j]`，则 `j` 回退到 `next[j]`，直到匹配或 `j = -1`。

**构建代码示例：**
```java
private static int[] computeNext(String pattern) {
    int[] next = new int[pattern.length()];
    next[0] = -1;
    int i = 0, j = -1;
    while (i < pattern.length() - 1) {
        if (j == -1 || pattern.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;
            next[i] = j; // 记录最长公共前后缀长度
        } else {
            j = next[j]; // 回退到前缀位置
        }
    }
    return next;
}
```
#### 三、匹配过程
1. ​**初始化**​：主串指针 `i=0`，模式串指针 `j=0`。
2. ​**循环匹配**​：
    - 若 `j == -1` 或 `text[i] == pattern[j]`，则 `i++` 和 `j++`。
    - 若不匹配，则 `j = next[j]`（模式串指针回退）。
3. ​**终止条件**​：
    - `j == pattern.length()`：匹配成功，返回 `i - j`。
    - `i >= text.length()`：匹配失败，返回 `-1`。

​**匹配过程示例**​：  
主串 `ABABDABACDABABCABAB`，模式 `ABABCABAB`：

1. 初始时 `i=0`, `j=0`。
2. 匹配到 `j=4`（字符 `C`）时失败，`j` 回退到 `next[4]=2`。
3. 继续匹配主串 `i=4` 和模式 `j=2`，最终在 `i=10` 处完成匹配。
#### 四、时间复杂度分析
- ​**预处理阶段**​：构建 `next` 数组的时间复杂度为 O(m)（`m` 为模式串长度）。
- ​**匹配阶段**​：主串遍历的时间复杂度为 O(n)（`n` 为主串长度）。
- ​**总复杂度**​：O(n+m)，远优于暴力法的 O(n×m)。
#### 五、`KMP`的优势与局限
##### **1. 优势**​
- ​**减少无效比较**​：通过 `next` 数组跳过已匹配部分的重复比较。
- ​**线性时间复杂度**​：适合处理长文本或高频匹配场景。
##### ​**2. 局限**​
- ​**空间开销**​：需额外存储 `next` 数组（空间复杂度 O(m)）。
- ​**适用性**​：对短模式串效果不明显，可能不如暴力法高效。
#### 六、`KMP`的变种与拓展
1. ​**优化版 `next` 数组**​：
    - 将 `next` 数组中的 `0` 替换为 `-1`，简化回退逻辑。
    - 例如：原 `next` 数组 `[ -1, 0, 0, 1, 2 ]` 优化为 `[ -1, -1, -1, 0, 0 ]`。
2. ​**BM算法（Boyer-Moore）​**​：
    - 结合“坏字符规则”和“好后缀规则”，实际效率通常高于 `KMP`。
3. ​**AC自动机**​：
    - 多模式串匹配算法，基于 `Trie` 树和 `KMP` 思想，支持同时匹配多个模式。
#### 七、实际应用场景
1. ​**文本搜索**​：如 IDE 的全局搜索、日志分析。
2. ​**生物信息学**​：DNA 序列匹配。
3. ​**网络协议**​：解析 HTTP 报文头、协议字段。
4. ​**编译器**​：词法分析中的关键字匹配。
