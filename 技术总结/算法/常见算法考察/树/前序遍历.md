---
创建时间: 2025-04-15 00:01:50
作者: wangxiaoming
tags:
  - 算法
  - 树
---
##### 1）题目

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例 1：**

**输入：**root = [1,null,2,3]

**输出：**[1,2,3]

**解释：**

![](https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png)

**示例 2：**

**输入：**root = [1,2,3,4,5,null,8,null,null,6,7,9]

**输出：**[1,2,4,5,6,7,3,8,9]

**解释：**

![](https://assets.leetcode.com/uploads/2024/08/29/tree_2.png)

**示例 3：**

**输入：**root = []

**输出：**[]

**示例 4：**

**输入：**root = [1]

**输出：**[1]

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`
##### 2）解题思路
递归实现：通过写递归方法，方法内按照顺序调用，三种顺序都可以用递归
使用栈实现：通过把根节点存栈中，通过出栈进行再遍历
左右入栈：通过栈的属性，先进后出，来实现前序效果,需要判空，不然没有结果返回，因为栈一直空
##### 2）代码实践
```java
//递归实现
public static List<Integer> preorderTraversa(TreeNode root){
   List<Integer> result = new ArrayList<>();
   preOrder(root,result);
   return result;
}

private static preOrder(TreeNode node,List<Integer> result){
   if(node == null) return result;
   result.add(node.val);
   preOrder(node.left,result);
   preOrder(node.right,result);
}

//使用栈实现
public static List<Integer> preorderTraversa(TreeNode root){
   List<Integer> result = new ArrayList<>();
   ArrayDeque<TreeNode> stack = new ArrayDeque<>();
   TreeNode node = root;
   while(node != null || !stack.isEmpty()){
      while(node != null){
          result.add(node.val);
          stack.push(node); //入栈
          node = node.left;
      }
      if(!stack.isEmpty()){
          node = stack.pop();
          node = node.right;
      }
   }
   return result;
}

//左右入栈实现
public static List<Integer> preorderTraversa(TreeNode root){
   List<Integer> result = new ArrayList<>();
   if(root == null) return result;
   ArrayDeque<TreeNode> stack = new ArrayDeque<>();
   stack.push(root);
   while(!stack.isEmpty()){
      TreeNode node = stack.pop();
      result.add(node.val);
      if(node.right != null) stack.push(node.right); //先入后出
      if(node.left != null) stack.push(node.left); //后入先出
   }
   return result;
}
```

#### 二、中序遍历
