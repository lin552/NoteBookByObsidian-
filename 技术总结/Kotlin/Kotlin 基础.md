---
创建时间: 2025-04-25 18:06:03
作者: wangxiaoming
tags:
  - Kotlin
---
#### 一、空安全

##### 1）类型系统区分可空与非空
- **非空类型**​（如 `String`）：默认不允许赋值为 `null`，编译时强制检查。
- ​**可空类型**​（如 `String?`）：显式声明允许 `null`，需通过安全操作符处理。  
    _设计目标_：通过类型系统在编译期消除空指针异常（`NPE`）
##### 2）空安全的三类操作符

|​**操作符**​|​**用途**​|​**示例**​|
|---|---|---|
|`?.`|安全调用（若左值为 `null`，则整个表达式返回 `null`）|`user?.name`|
|`?:`|Elvis 操作符（提供默认值）|`age?: 18`|
|`!!`|非空断言（强制转换，可能抛出 NPE）|`list!!.size`|
##### 3）空安全优势
1. ​**减少 `NPE` 风险**​
    - 编译期检查可空类型，避免运行时崩溃（如 Java 中常见的 `NullPointerException`）
2. ​**代码简洁性**​
    - 通过 `?.` 替代多层 `if (obj != null)` 判断，简化链式调用。
3. ​**类型安全性**​
    - 强类型系统结合泛型，确保集合、函数参数等场景的类型一致性
##### 4）实际应用场景
###### ① 安全访问链式调用
```kotlin
val length = user?.address?.city?.length ?: 0
// 若任一环节为null,最终返回0
```
###### ② 默认值处理
```kotlin
val price:Double? = null
val finalPrice = price ?: 9.99 //提供默认值
```
###### ③ 类型转换安全
```kotlin
val obj:Any? = "Hello"
val strLength:Int? = obj?.toString()?.length //避免ClassCastException
```
###### ④ 与Java互操作
- **调用 Java 方法**​：使用 `?.` 避免 `NPE`（如 `javaObj?.getValue()`）。
- ​**暴露 Kotlin API 给 Java**​：使用 `@NotNull` 和 `@Nullable` 注解明确约束
##### 4）与Java的对比
| ​**特性**​     | ​**Kotlin**​             | ​**Java**​               |
| ------------ | ------------------------ | ------------------------ |
| ​**默认可空性**​  | 非空类型（需显式标记 `?` 为可空）      | 允许 `null`                |
| ​**空检查机制**​  | 编译期强制检查                  | 运行时通过 `if (obj != null)` |
| ​**类型安全**​   | 通过泛型、`reified` 增强        | 依赖注解（如 `@NonNull`）       |
| ​**函数式操作符**​ | 支持 `?.`、`?:`、`as?` 等链式操作 | 需手动实现                    |
##### 5）常见问题与解决方案
1. 问题 1：Java 调用 Kotlin 可空类型时报 `NPE`
	- ​**解决方案**​：
	    - Kotlin 侧使用 `@JvmField` 或 `@JvmOverloads` 暴露非空字段。
	    - Java 侧添加 `@NotNull` 注解（需引入 `kotlin-stdlib-jdk8`）。
2.  问题 2：泛型中的空安全
	- ​**解决方案**​：
	    - 使用 `reified` 关键字保留类型信息（需 `inline` 函数）。
#### 二、四种范围修饰符
##### `public`
- ​**范围**​：所有地方可见（默认修饰符）。
- ​**适用场景**​：需要暴露给外部模块或类的 API。
##### `private`
- **范围**​：仅声明所在的 ​**类或文件**​ 内可见。
- ​**适用场景**​：隐藏实现细节（如内部工具方法）。
- ​**限制**​：
    - 顶层声明的 `private` 仅当前文件可见。
    - 类内部成员的 `private` 仅本类可见。
##### `protected`
- ​**范围**​：声明所在的 ​**类、子类及同一模块**​ 内可见。
- ​**适用场景**​：允许子类重写或扩展的成员。
- ​**限制**​：
    - ​**不能用于顶层声明**​（如包级函数或属性）。
    - 子类重写时若未指定可见性，默认继承 `protected`。
##### `internal`
- **范围**​：同一 ​**模块**​ 内可见（编译单元，如 `IntelliJ` 模块或 `Gradle` 项目）。
- ​**适用场景**​：模块内共享但不暴露给外部的功能。
- ​**特性**​：
    - 编译后实际为 `public`，但 `JVM` 名称会被混淆（如 `internalFun$moduleName`），防止 Java 跨模块调用。
    - 与 `open` 结合可实现模块内继承。
##### 1）不同场景下的可见性规则
###### 顶层声明（包级别）
| 修饰符         | 同一文件 | 其他文件 | 同一模块 | 其他模块 |
| ----------- | ---- | ---- | ---- | ---- |
| `public`    | ✅    | ✅    | ✅    | ✅    |
| `private`   | ✅    | ❌    | ❌    | ❌    |
| `internal`  | ✅    | ❌    | ✅    | ❌    |
| `protected` | ❌    | ❌    | ❌    | ❌    |
###### 类/接口成员
|修饰符|类内部|子类|同一模块|其他模块|
|---|---|---|---|---|
|`public`|✅|✅|✅|✅|
|`private`|✅|❌|❌|❌|
|`protected`|✅|✅|❌|❌|
|`internal`|✅|❌|✅|❌|
###### 构造函数
- ​**主构造函数**​：默认 `public`，可显式指定 `private`（单例模式常用）。
- ​**次构造函数**​：遵循局部作用域规则（类似函数）。