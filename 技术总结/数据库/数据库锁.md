---
创建时间: 2025-05-17 15:42:23
作者: wangxiaoming
tags:
  - 数据库
  - 锁
---
#### 一、按锁粒度分类
##### **1. 行锁（Row-Level Lock）​**​
- ​**定义**​：锁定表中某一行数据，仅允许当前事务操作该行，其他事务需等待锁释放。
- ​**特点**​：
    - ​**高并发**​：允许多个事务同时操作不同行，适合高并发 `OLTP` 场景。
    - ​**死锁风险**​：频繁的行锁可能导致死锁（如事务A锁行1后请求行2，事务B锁行2后请求行1）。
- ​**实现引擎**​：`InnoDB`（通过记录锁 `Record Lock` 实现）。
- ​**示例**​：
```sql
UPDATE users SET age = 30 WHERE id = 1; -- 锁定 id=1 的行
```
##### ​**2. 表锁（Table-Level Lock）​**​
- ​**定义**​：锁定整个表，其他事务无法读写该表，直到锁释放。
- ​**特点**​：
    - ​**低并发**​：同一时间仅允许一个事务操作表，适合低频 `OLAP` 或 `DDL` 操作。
    - ​**简单高效**​：无死锁风险，但性能较差。
- ​**实现引擎**​：`MyISAM`（默认表锁）。
- ​**示例**​：
```sql
LOCK TABLES users WRITE; -- 锁定整个表
ALTER TABLE users ADD COLUMN age INT; -- DDL 操作需表锁
UNLOCK TABLES; -- 释放锁
```
##### ​**3. 页锁（Page-Level Lock）​**​
- ​**定义**​：锁定数据页（如 `16KB` 的页），同一页内的多行数据被锁定。
- ​**特点**​：
    - ​**折中方案**​：介于行锁和表锁之间，减少锁冲突，但仍有并发限制。
    - ​**已淘汰**​：现代数据库（如 MySQL）已基本弃用。

#### 二、按锁范围分类
##### **1. 全局锁（Global Lock）​**​
- ​**定义**​：锁定整个数据库实例，禁止所有写操作（读操作可能允许）。
- ​**场景**​：
    - ​**数据迁移**​：如 `FLUSH TABLES WITH READ LOCK` 用于备份。
    - ​**主从同步**​：确保主库数据一致性。
- ​**风险**​：长时间持有会导致数据库完全阻塞。
- ​**示例**​：
```sql
FLUSH TABLES WITH READ LOCK; -- 全局读锁
mysqldump -u root -p dbname > backup.sql # 备份期间禁止写
UNLOCK TABLES; # 释放锁
```
##### ​**2. 记录锁（Record Lock）​**​
- ​**定义**​：锁定索引中的某条记录（行锁的底层实现）。
- ​**特点**​：
    - 仅锁定符合条件的记录，非索引字段可能升级为表锁。
- ​**示例**​：
```sql
SELECT * FROM users WHERE id = 1 FOR UPDATE; -- 锁定 id=1 的记录
```
##### ​**3. 间隙锁（Gap Lock）​**​
- ​**定义**​：锁定索引记录之间的间隙（如 `(10, 20)`），防止其他事务在此区间插入数据。
- ​**场景**​：
    - ​**可重复读（RR）隔离级别**​：解决幻读问题（如 `SELECT ... WHERE id > 10 FOR UPDATE` 锁定 `id>10` 的间隙）。
- ​**风险**​：可能降低并发性能（如大量间隙锁导致插入阻塞）。
- ​**示例**​：
```sql
-- 事务A
START TRANSACTION;
SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE;

-- 事务B
INSERT INTO users (id, name) VALUES (15, 'Alice'); -- 被阻塞，直到事务A提交
```
##### ​**4. 临键锁（Next-Key Lock）​**​
- ​**定义**​：组合记录锁和间隙锁，锁定索引记录及其右侧间隙（如 `[10, 20)`）。
- ​**场景**​：
    - ​`InnoDB` 的 RR 隔离级别**​：防止幻读（如 `SELECT ... WHERE id >= 10 FOR UPDATE`）。
- ​**示例**​：
```sql
-- 事务A
START TRANSACTION;
SELECT * FROM users WHERE id >= 10 FOR UPDATE; -- 锁定 id>=10 的记录及间隙

-- 事务B
INSERT INTO users (id, name) VALUES (15, 'Bob'); -- 被阻塞
```

#### 三、按锁策略分类
##### **乐观锁（Optimistic Locking）​**​
- ​**原理**​：假设冲突概率低，通过版本号或时间戳实现（无真实锁）。
- ​**实现**​：
```sql
UPDATE users SET age = 30, version = version + 1 
WHERE id = 1 AND version = 5; -- 检查版本号是否匹配
```
- ​**场景**​：读多写少，冲突概率低的场景（如电商库存扣减）。
##### ​**2. 悲观锁（Pessimistic Locking）​**​
- ​**原理**​：假设冲突概率高，提前加锁（如 `SELECT ... FOR UPDATE`）。
- ​**场景**​：写多读少，高并发冲突场景（如金融交易）。
#### 四、锁的兼容性
|​**锁类型**​|记录锁|间隙锁|临键锁|表锁|
|---|---|---|---|---|
|​**记录锁**​|冲突|兼容|冲突|冲突|
|​**间隙锁**​|兼容|兼容|冲突|冲突|
|​**临键锁**​|冲突|冲突|兼容|冲突|
|​**表锁（写）​**​|冲突|冲突|冲突|冲突|
|​**表锁（读）​**​|兼容|兼容|兼容|兼容|
#### 五、锁的性能影响与优化
1. ​**减少锁粒度**​：尽量使用行锁而非表锁。
2. ​**控制事务范围**​：缩短事务执行时间，减少锁持有时间。
3. ​**避免长事务**​：通过 `SHOW PROCESSLIST` 监控并终止阻塞事务。
4. ​**合理选择隔离级别**​：如 RC（Read Committed）比 RR（Repeatable Read）锁竞争更少。
#### 六、总结
|​**锁类型**​|​**作用范围**​|​**典型场景**​|​**风险**​|
|---|---|---|---|
|行锁|单行数据|OLTP 高频写操作|死锁、性能开销|
|表锁|整个表|DDL 操作、低频读写|严重并发瓶颈|
|全局锁|数据库实例|备份、主从同步|完全阻塞|
|间隙锁|索引间隙|防止幻读（RR 隔离级别）|插入阻塞、降低并发|
|临键锁|记录+间隙|高并发 RR 隔离级别|与间隙锁类似|
