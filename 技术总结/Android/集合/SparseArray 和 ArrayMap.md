---
创建时间: 2025-03-14T18:39:00
作者: wangxiaoming
tags:
  - SpareseArray
  - ArrayMap
  - 集合
---
#### 一、深度解析
##### 1）SparseArray
- ​**定位**：专为 ​**`int` 类型 Key** 设计的键值存储结构，用于替代 `HashMap<Integer, Object>`
- ​**优化点**：避免 `int` 到 `Integer` 的自动装箱，减少内存占用；通过二分查找提升小数据量下的查询效率
- ​**适用场景**：数据量小（千级以内）、Key 为 `int` 的稀疏数据（如缓存视图 ID 与对象）

##### 2）ArrayMap
- ​**定位**：通用型键值存储结构，支持 ​**任意对象类型 Key**，替代 `HashMap<Object, Object>`
- ​**优化点**：通过双数组（哈希值数组、键值对数组）减少内存碎片；保持插入顺序，适合需要有序遍历的场景（如 `Bundle` 底层存储）
- ​**适用场景**：中小规模数据（千级以内）、需保持插入顺序或键类型非 `int` 的场景

#### 二、内部实现与原理
##### 1）SparseArray的内部结构
- **数据结构**：两个数组 `int[] mKeys` 和 `Object[] mValues`，Key 按升序排列
- ​**操作逻辑**：
    - ​**增删改查**：基于二分查找定位索引，时间复杂度为 `O(log n)`
    - ​**内存压缩**：删除元素时标记为 `DELETED`，延迟物理删除以减少数组拷贝开销


##### 2）ArrayMap的内部结构
- ​**数据结构**：
    - `int[] mHashes`：存储 Key 的哈希值，按升序排列。
    - `Object[] mArray`：交替存储 Key 和 Value（偶数索引存 Key，奇数索引存 Value）
- ​**操作逻辑**：
    - ​**哈希冲突处理**：开放寻址法（线性探测），无链表或红黑树结构
    - ​**扩容策略**：容量翻倍或收缩至当前元素数的 1.5 倍，平衡内存与性能


#### 三、性能对比与使用场景
| **维度**      | ​**SparseArray**                     | ​**ArrayMap**                | ​**HashMap**           |
| ----------- | ------------------------------------ | ---------------------------- | ---------------------- |
| ​**Key 类型** | `int`（支持 `long` 的 `LongSparseArray`） | 任意对象类型                       | 任意对象类型（需实现 `hashCode`） |
| ​**内存占用**   | 更低（避免自动装箱，无哈希表结构）                    | 低于 HashMap（无链表/红黑树）          | 高（哈希表 + 链表/红黑树）        |
| ​**查询效率**   | 数据量小（千级内）时更快（二分查找）                   | 数据量小（千级内）时优于 HashMap         | 大数据量下更优（哈希直接定位）        |
| ​**插入顺序保留** | 按 Key 升序排列                           | 保留插入顺序                       | 不保留（哈希散列）              |
| ​**适用场景**   | 稀疏 `int` Key 的缓存（如视图 ID 映射）          | 中小规模通用 Map、需有序遍历（如 `Bundle`） | 大数据量或高频增删场景            |
#### 四、最佳实践
##### 1）SparseArray最佳实践
- **替代场景**：优先用于 `int` Key 的缓存（如 `RecyclerView` 的 `ViewHolder` 缓存）
- ​**性能陷阱**：数据量超过千级时性能显著下降（二分查找开销增加），需评估数据规模
- ​**变体类**：
    - `SparseIntArray`/`SparseBooleanArray`：Value 为基本类型，进一步减少内存
    - `LongSparseArray`：Key 为 `long` 类型
##### 2）ArrayMap最佳实践
- **替代场景**：中小规模通用 Map（如配置项存储、`Activity` 参数传递）
- ​**内存优化**：通过 `clear()` 或 `erase()` 主动释放空间，避免内存泄漏
- ​**线程安全**：非线程安全，多线程操作需同步