#### 一、算法详解
##### 1）算法流程
###### ①根节点枚举（Root Scanning）
- 遍历所有 GC Roots（如栈帧、静态变量、JNI 引用等）
- ​**优化手段**：HotSpot 使用 ​**OopMap** 数据结构记录堆内对象引用位置，加速根节点扫描

###### ②标记阶段（Marking）
- 从 GC Roots 出发，通过深度优先或广度优先遍历标记所有可达对象
- ​**并发标记**：CMS、G1 等回收器使用写屏障（Write Barrier）处理用户线程并发修改引用的情况

###### ③清理阶段（Sweeping/Compacting）
根据标记结果，释放不可达对象内存（标记-清除）或整理存活对象（标记-整理）

##### 2）算法核心挑战与解决方案
- ​**循环引用问题**：  
    引用计数法无法处理循环引用（如对象 A 引用 B，B 引用 A），但可达性分析通过 GC Roots 的全局性遍历可自然解决
- ​**多线程环境下的准确性**：  
    采用 ​**STW（Stop-The-World）​** 暂停用户线程，或通过 ​**三色标记法** 实现并发标记（如 ZGC 的染色指针）

##### 3）算法性能优化
- **增量式分析**：将标记过程分解为多个小阶段，减少单次停顿时间（如增量标记）
- ​**并行处理**：多线程同时扫描不同 GC Roots 或堆区域（如 Parallel GC）