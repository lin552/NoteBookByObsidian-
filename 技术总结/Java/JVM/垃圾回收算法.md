---
创建时间: 2025-03-14T18:39:00
作者: wangxiaoming
tags:
  - JVM
---
GC Roots 是垃圾回收机制中判断对象存活的逻辑起点，​[[可达性分析算法]]从这些根对象出发，遍历引用链以确定存活对象。未被引用的对象被标记为垃圾，等待回收。两者的关系可概括为：
- ​**GC Roots 是可达性分析的入口**：所有存活对象必须与 GC Roots 存在直接或间接引用链
- ​**垃圾回收的准确性依赖 GC Roots 的完整性**：若遗漏某些根对象，可能导致存活对象被误回收（如未正确处理 JNI 引用）
#### 一、GC Roots分类
##### 1)虚拟机栈中的引用
**具体对象**：当前线程的栈帧中的局部变量、方法参数、临时变量等。
```java
void method() {
    Object localObj = new Object(); // localObj 是 GC Root
}
```
**特点**：线程私有，随方法结束而销毁
##### 2)本地方法栈中的JNI引用
- ​**具体对象**：通过 JNI（Java Native Interface）调用的本地方法中引用的 Java 对象。
- ​**示例**：C/C++ 代码通过 JNI 函数 `NewGlobalRef` 创建的全局引用

##### 3)方法区中的静态属性引用
**具体对象**：类的静态变量（`static` 修饰的字段）
```java
public class MyClass {
    static Object staticObj = new Object(); // staticObj 是 GC Root
}
```
**特点**：生命周期与类相同，需类卸载后才会失效

##### 4)方法区中的常量引用
**具体对象**：字符串常量池中的引用（如 `String s = "abc"`）、`static final` 修饰的常量。
```java
public static final Object CONST = new Object(); // CONST 是 GC Root
```
**注意**：基本类型常量（如 `final int x = 1`）不涉及对象引用

##### 5)被同步锁持有的对象
**具体对象**：通过 `synchronized` 持有的对象。
```java
synchronized (lockObj) { // lockObj 是 GC Root
    // 代码块
}
```
​**作用**：确保锁对象在同步期间不被回收

##### 6)Java虚拟机内部引用
​**具体对象**：
- 系统类加载器加载的核心类（如 `java.lang.String` 的 `Class` 对象）。
- 常驻异常对象（如 `NullPointerException`、`OutOfMemoryError`）。
- 基本数据类型对应的 `Class` 对象（如 `Integer.TYPE`）

##### 7)活跃线程对象
**具体对象**：正在运行的线程实例（`Thread` 对象）及其栈帧中的本地变量。
```java
Thread thread = new Thread(() -> {
    Object localObj = new Object(); // localObj 是 GC Root
});
```
**特点**：线程未终止时，其引用的对象保持存活

##### 8)跨代引用对象
- **具体对象**：老年代中引用新生代对象的实例（通过 `CardTable` 机制记录）。
- ​**示例**：老年代对象 `OldObj` 持有新生代对象 `YoungObj` 的引用时，`OldObj` 在新生代 GC 时被视为 GC Root



#### 二、基础回收算法
##### 1)标记-清除算法（Mark-Sweep）
- **原理**：  
    分为标记和清除两阶段。首先从 GC Roots（如栈变量、静态变量等）出发，标记所有可达对象；随后遍历堆内存，清除未被标记的对象
- ​**优点**：实现简单，无需移动对象
- ​**缺点**：
    - 产生内存碎片，可能导致大对象分配失败
    - 两次遍历堆内存（标记和清除），效率较低
- ​**应用场景**：老年代垃圾回收（如 CMS 回收器的初始阶段）

##### 复制算法（Copying）
- **原理**：  
    将内存分为两块（如 Eden 区和 Survivor 区），仅使用其中一块。回收时将存活对象复制到另一块空闲区域，并清空原区域
- ​**优点**：
    - 无内存碎片，分配效率高（指针碰撞即可分配）
    - 适合短生命周期对象
- ​**缺点**：
    - 内存利用率仅 50%（需预留备用空间）
    - 对象存活率高时复制成本大
- ​**应用场景**：新生代回收（默认 Eden 与 Survivor 区比例 8:1:1）

##### 标记-整理算法 （Mark-Compact）
- **原理**：  
    标记阶段与标记-清除相同，但后续将存活对象向内存一端移动，清理边界外空间
- ​**优点**：
    - 无内存碎片，适合长期存活对象
    - 内存分配效率高（连续空间）
- ​**缺点**：对象移动带来额外开销，影响回收速度
- ​**应用场景**：老年代回收（如 Serial Old、Parallel Old 回收器）

#### 三、优化策略算法
##### 1)分代收集算法（Generational Collection)
- **原理**：  
    基于对象生命周期差异，将堆划分为新生代（Young Generation）和老年代（Old Generation），分别采用不同算法：
    - ​**新生代**：高频回收，使用复制算法（存活率低）
    - ​**老年代**：低频回收，使用标记-清除或标记-整理算法（存活率高）
- ​**设计依据**：
    - ​**弱分代假说**：绝大多数对象生命周期短
    - ​**跨代引用处理**：通过记忆集（Remembered Set）记录跨代引用
- ​**优势**：针对不同对象特性优化效率，降低全局回收频率

##### 2)分区算法（Region-Based Collection）
- **原理**：  
    将堆内存划分为多个大小相等的区域（Region），优先回收垃圾比例高的区域（如 G1 回收器）
- ​**特点**：
    - 动态分配区域为 Eden、Survivor 或 Old 区
    - 可预测停顿时间（通过设定最大暂停时间目标）
- ​**应用场景**：大堆内存场景（如 G1、ZGC 回收器）

#### 四、算法对比
|**算法类型**|​**内存碎片**|​**吞吐量**|​**停顿时间**|​**适用场景**|
|---|---|---|---|---|
|标记-清除|严重|中等|较长|老年代（CMS 初始阶段）|
|复制|无|高|短|新生代|
|标记-整理|无|低|较长|老年代（高内存连续性需求）|
|分代收集（综合）|可控|高|可调|全堆（主流方案）|
|分区（G1/ZGC）|无|高|极短|大堆、低延迟场景|
