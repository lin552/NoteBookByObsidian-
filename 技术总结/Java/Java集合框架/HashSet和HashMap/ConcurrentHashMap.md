---
创建时间: 2025-04-12 17:24:57
作者: wangxiaoming
tags:
  - 集合
  - HashMap
---
`ConcurrentHashMap` 是 Java 并发包（`java.util.concurrent`）中的核心线程安全哈希表，专为高并发场景设计，兼顾性能与安全性

#### 一、核心特性
##### 1）线程安全性
- 通过 ​**分段锁（JDK 1.7）​** 或 ​**CAS + synchronized（JDK 1.8+）​** 实现高效并发控制，避免 `Hashtable` 的全表锁性能瓶颈
- ​**读操作无锁化**：通过 `volatile` 变量保证可见性，读取时无需加锁

##### 2）数据结构
- ​**JDK 1.7**：`Segment 数组 + HashEntry 链表`，每个 `Segment` 继承 `ReentrantLock`，分段锁机制允许最多 16 个线程并发写入不同段
- ​**JDK 1.8+**：移除 `Segment`，采用 `Node 数组 + 链表 + 红黑树`，锁粒度细化到链表头节点（仅锁冲突桶），并发度显著提升

##### 3）高性能
- ​**CAS 优化**：插入空桶时使用 CAS（Compare-And-Swap）无锁操作，减少线程阻塞
- ​**红黑树优化**：链表长度 ≥8 时转为红黑树，查询复杂度从 O(n) 降至 O(log n)

#### 二、JDK1.7 与JDK1.8+的实现对比
| **维度**    | ​**JDK 1.7**              | ​**JDK 1.8+**                |
| --------- | ------------------------- | ---------------------------- |
| ​**数据结构** | Segment 数组 + HashEntry 链表 | Node 数组 + 链表 + 红黑树           |
| ​**锁机制**  | 分段锁（每个 Segment 独立锁）       | CAS + synchronized（锁单个链表头节点） |
| ​**并发度**  | 默认 16（由 Segment 数量决定）     | 更高（锁粒度细化到桶级别）                |
| ​**扩容机制** | 段内扩容，需重哈希                 | 多线程协同扩容，逐步迁移数据               |
| ​**性能瓶颈** | 段数固定，高并发下段内竞争仍存在          | 锁竞争减少，CAS 提升低竞争场景效率          |
**JDK 1.8+ 核心优化**：
- ​**取消分段锁**：减少内存开销，简化代码结构
- ​**CAS + synchronized 结合**：低竞争时 CAS 插入，高竞争时退化为 `synchronized` 锁
- ​**树化与逆树化**：动态调整数据结构以适应数据分布

#### 三、关键源码与核心操作分析
##### 1）初始化与参数
- ​**构造方法**：支持指定初始容量、负载因子和并发度（JDK 1.7）
    。JDK 1.8 通过 `sizeCtl` 控制初始化和扩容状态
- ​**哈希扰动**：`spread()` 方法混合高位和低位哈希值，减少冲突

##### 2）put操作流程（JDK 1.8）
```java
final V putVal(K key, V value, boolean onlyIfAbsent) {
    int hash = spread(key.hashCode());
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable(); // 初始化数组
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value))) // CAS 插入
                break;
        } else {
            synchronized (f) { // 锁住链表头节点
                // 处理链表或红黑树插入
            }
        }
    }
    return null;
}
```

- ​`CAS` 插入空桶：无锁化操作提升性能
- ​**锁链表头节点**：仅锁冲突桶，其他桶仍可并发访问

##### 3）扩容机制
- **多线程协同**：通过 `ForwardingNode` 标记迁移中的桶，其他线程协助迁移
- ​**渐进式迁移**：避免一次性扩容导致长时间阻塞

#### 四、与`HashMap`、`Hashtable`（废弃）的对比
| ​**特性**      | ​**HashMap**        | ​**Hashtable**    | ​**ConcurrentHashMap**  |
| ------------ | ------------------- | ----------------- | ----------------------- |
| ​**线程安全**    | 非线程安全               | 全表锁（synchronized） | 分段锁或 CAS + synchronized |
| ​**Null 支持** | 允许 Key/Value 为 Null | 禁止                | 禁止                      |
| ​**性能**      | 单线程高效               | 低并发下性能差           | 高并发下性能优越                |
| ​**适用场景**    | 单线程环境               | 遗留代码或低并发场景        | 高并发读写需求（如缓存、计数器）        |
**优势总结**：
- ​**高并发读**：无锁设计提升吞吐量
- ​**高效写**：锁粒度细化减少竞争
- ​**动态扩展**：支持按需扩容和数据结构优化

#### 五、使用场景与最佳实践
1. ​**典型场景**
    - ​**高并发缓存**：如全局缓存系统，支持多线程安全读写
    - ​**计数器/限流器**：利用原子方法（如 `computeIfAbsent()`）实现频率统计或滑动窗口限流
    - ​**配置管理**：存储动态配置参数，支持实时更新与读取
2. ​**使用建议**
    - ​**避免频繁扩容**：初始化时合理设置容量和负载因子
    - ​**键设计**：使用不可变对象（如 `String`、`Integer`）作为 Key
    - ​**线程安全方法**：优先使用 `putIfAbsent()`、`compute()` 等原子方法