---
创建时间: 2025-04-11 23:44:32
作者: wangxiaoming
tags:
  - Set
---

#### 一、Set 特性对比

| ​**特性**​        | ​**HashSet**​<br> | ​**LinkedHashSet**​<br>           | ​**TreeSet**​<br>                 | ​**ConcurrentSkipListSet**​                       | ​**CopyOnWriteArraySet**​       |
| --------------- | ----------------- | --------------------------------- | --------------------------------- | ------------------------------------------------- | ------------------------------- |
| ​**底层数据结构**​    | 哈希表（数组+链表/红黑树）    | 哈希表 + 双向链表                        | 红黑树                               | 跳表（SkipList）                                      | 动态数组（基于 `CopyOnWriteArrayList`） |
| ​**元素顺序**​      | 无序                | 按插入顺序                             | 自然排序或自定义比较器排序                     | 自然排序或自定义比较器排序                                     | 无序                              |
| ​**时间复杂度**​     | 插入/查找：均摊 O(1)     | 插入/查找：均摊 O(1)                     | 插入/查找：O(log n)                    | 插入/查找：O(log n)                                    | 插入：O(n)，查找：O(n)                 |
| ​**线程安全**​      | 非线程安全             | 非线程安全                             | 非线程安全                             | 线程安全（并发操作）                                        | 线程安全（写时复制）                      |
| ​**允许 Null 值**​ | 允许                | 允许                                | 不允许（除非自定义比较器支持）                   | 不允许                                               | 允许                              |
| ​**内存占用**​      | 中等                | 较高（额外维护链表）                        | 较低（树结构紧凑）                         | 较高（跳表多层索引）                                        | 高（写时复制全量数组）                     |
| **obsidian链**   | [[HashSet]]       | [[LinkedHashMap 和 LinkedHashSet]] | [[TreeMap 和 TreeSet#2）`TreeSet`]] | [[ConcurrentSkipListMap 和 ConcurrentSkipListSet]] |                                 |

#### 二、Set 适用场景
##### ① 基于排序需求
###### 1. ​**无需排序，仅需去重**​
- ​**选择 `HashSet`**​
    - ​**技术优势**​：基于哈希表实现，`add`/`contains` 操作平均时间复杂度 ​**O(1)​**，内存占用中等
    - ​**适用场景**​：高频查询、数据去重（如缓存键存储）、无顺序要求的唯一性校验
    - ​**限制**​：元素无序，不支持范围查询。
###### 2. ​**需保留插入顺序**​
- ​**选择 `LinkedHashSet`**​
    - ​**技术优势**​：在 `HashSet` 基础上通过双向链表维护插入顺序，`add`/`contains` 仍为 ​**O(1)​**，但内存略高
    - ​**适用场景**​：需按插入顺序迭代（如 `LRU` 缓存实现）、日志记录顺序保持
###### 3. ​**需自然或自定义排序**​
- ​**选择 `TreeSet` 或 `ConcurrentSkipListSet`**​
    - ​**技术差异**​：
        - `TreeSet`：基于红黑树，操作时间复杂度 ​**O(log n)​**，线程不安全
        - `ConcurrentSkipListSet`：基于跳表，支持并发操作，操作时间复杂度 ​**O(log n)​**，内存较高
    - ​**适用场景**​：
        - `TreeSet`：单线程下有序集合（如按分数排序的排行榜）
        - `ConcurrentSkipListSet`：高并发有序集合（如实时更新的分布式排行榜）
##### ② 基于并发需求
###### 1. ​**读多写少场景**​
- ​**选择 `CopyOnWriteArraySet`**​
    - ​**技术优势**​：基于写时复制机制，读操作无锁，写操作复制全量数组，适合低频修改
    - ​**适用场景**​：监听器列表、配置项存储（如黑名单）
    - ​**限制**​：写入性能差（O(n)），大数据量时内存压力大。
###### 2. ​**高并发读写场景**​
- ​**选择 `ConcurrentSkipListSet`**​
    - ​**技术优势**​：跳表结构支持无锁并发操作，线程安全且性能稳定
    - ​**适用场景**​：多线程下需有序集合（如实时竞价系统）
##### ③ 基于数据类型与内存优化
###### 1. **处理枚举类型**​
- ​**选择 `EnumSet`**​
    - ​**技术优势**​：基于位向量实现，内存占用极低（每个枚举常量占 1 位），操作时间复杂度 ​**O(1)​**​
    - ​**适用场景**​：状态机、权限集合（如用户角色）
    - ​**限制**​：仅支持同一枚举类型元素。
###### 2. ​**内存敏感场景**​
- ​**优先选择 `HashSet` 或 `EnumSet`**​
    - `HashSet`：哈希表结构紧凑，适合通用数据类型
    - `EnumSet`：位向量存储，内存效率最高（仅限枚举）
##### ④ 总结
- ​**无序 + 高性能**​ → `HashSet`
- ​**插入顺序保留**​ → `LinkedHashSet`
- ​**排序 + 单线程**​ → `TreeSet`
- ​**排序 + 高并发**​ → `ConcurrentSkipListSet`
- ​**枚举优化**​ → `EnumSet`
- ​**读多写少线程安全**​ → `CopyOnWriteArraySet`