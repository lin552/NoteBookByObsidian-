---
创建时间: 2025-03-14T18:39:00
作者: wangxiaoming
tags:
  - 集合
  - Java
  - HashMap
---
#### 一、基本概念与核心特性
- ​**定义**：HashMap 是 Java 中基于哈希表实现的键值对（Key-Value）集合，继承自 `AbstractMap` 类，非线程安全
- ​**特点**：
    - ​**键唯一性**：每个 Key 唯一，重复 Key 插入会覆盖旧值。
    - ​**允许 Null 值**：Key 和 Value 均可为 `null`
    - ​**无序性**：不保证插入顺序，需有序存储可使用 `LinkedHashMap`
    - ​**高效操作**：平均时间复杂度为 O(1)，查找、插入、删除性能优异

#### 二、底层数据结构与工作原理
- **数据结构**：
    - ​**数组 + 链表 + 红黑树**​（JDK 1.8 后优化）
        - ​**数组**：默认初始容量为 16，每个元素称为“桶”（Bucket）。
        - ​**链表**：哈希冲突时，相同桶内元素以链表存储。
        - ​**红黑树**：当链表长度 ≥8 且数组长度 ≥64 时，链表转为红黑树（查找复杂度由 O(n) 降至 O(log n)）
![[Pasted image 20250324081654.png]]

- ​**哈希函数**：
    - ​**扰动函数**：通过 `(h = key.hashCode()) ^ (h >>> 16)` 混合高位和低位哈希值，减少冲突概率
    - ​**定位桶索引**：通过 `(n - 1) & hash` 计算（等价于取模运算），其中 `n` 为数组长度

#### 三、哈希冲突处理与扩容机制
- **冲突解决**：
    - ​**链地址法**：冲突元素以链表存储，Java 8 后引入红黑树优化长链表
- ​**动态扩容**：
    - ​**触发条件**：当元素数量超过 `容量 × 负载因子（默认 0.75）` 时触发
    - ​**扩容过程**：新容量为原 2 倍，重新哈希所有元素到新数组，逐步迁移以减少性能损耗
#### 四、线程安全与并发问题
- **非线程安全**：多线程并发修改可能导致数据不一致、循环链表（JDK 1.7 前）等问题
- ​**解决方案**：
    - ​[[ConcurrentHashMap]]：基于分段锁（JDK 1.7）或 CAS + 同步块（JDK 1.8）实现高并发安全
    - ​**Collections.synchronizedMap**：通过同步包装类实现线程安全，但性能较低

#### 五、性能优化与使用建议
- ​**初始化参数**：
    - ​**初始容量**：预估元素数量，避免频繁扩容（建议 `初始容量 = 预期元素数 / 负载因子 + 1`）
    - ​**负载因子**：默认 0.75 平衡时间与空间效率
- ​**键设计**：
    - ​**不可变对象**：如 String、Integer，避免修改 Key 导致哈希值变化
    - ​**重写 hashCode() 和 equals()**：确保哈希分布均匀且相等性判断正确

#### 六、常见问题与注意事项
- ​**哈希冲突过多**：可能因 Key 的哈希函数设计不佳导致性能下降，需优化哈希算法
- ​**内存泄漏**：长期持有 HashMap 引用导致无法回收，需及时清理无用键值对