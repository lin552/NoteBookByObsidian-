---
创建时间: 2025-03-14T18:39:00
作者: wangxiaoming
tags:
  - Java
  - JMM
---

Java内存模型（Java Memory Model,JMM）是Java语言规范中定义的多线程内存访问规则，旨在解决多线程并发环境下的可见性、有序性和原子性问题，确保程序在不同硬件和操作系统平台上的行为一致性

#### 一、核心目标与作用
##### 1）可见性
确保一个线程对共享变量的修改能及时被其他线程感知。例如，使用 `volatile` 关键字强制线程从主内存读取最新值，避免因缓存导致的数据不一致

##### 2）有序性
通过 ​**happens-before 原则** 和 ​**内存屏障** 限制指令重排序，保证代码执行顺序符合预期。例如，单线程的 as-if-serial 语义允许编译器优化，但不会改变程序结果；多线程则依赖 happens-before 规则确定操作间的可见性顺序

##### 3）原子性
对基本数据类型（如 `int`）的读写操作默认具有原子性，但对 `long` 和 `double` 在 32 位系统中可能不保证原子性。通过 `synchronized` 或 `Lock` 可确保代码块的原子性

#### 二、内存模型组成

##### 1)主内存（Main Memory）
所有共享变量的存储区域，所有线程均可访问。主内存是逻辑概念，对应物理内存中的堆区

##### 2)工作内存（Working Memory）
每个线程私有的内存副本，保存线程操作所需的主内存变量拷贝。工作内存是抽象概念，可能对应 CPU 缓存、寄存器或编译器优化后的临时存储

**交互操作**：  
线程对变量的操作需通过 8 种原子指令完成（如 `read`、`load`、`use`、`assign`、`store`、`write` 等），确保数据在主内存与工作内存间的同步

#### 三、关键实现机制

##### 1) [[volatile 关键字]]
- 强制读写操作直接与主内存交互，禁止指令重排序（通过插入内存屏障）
- 典型应用：状态标记变量（如 `private volatile boolean flag`）

##### 2) [[synchronized 锁]]
- 通过监视器锁（Monitor）保证代码块原子性，并在解锁时自动将变量刷回主内存
- 优化：偏向锁、轻量级锁、自旋锁等减少锁开销

##### 3）happens-before原则 
定义操作间的偏序关系，例如：
- 程序顺序规则：单线程内代码顺序执行。
- 锁规则：解锁操作先于后续加锁操作。
- volatile 变量规则：写操作先于后续读操作