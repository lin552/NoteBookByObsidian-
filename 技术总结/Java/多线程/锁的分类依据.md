---
创建时间: 2025-03-14T18:39:00
作者: wangxiaoming
tags:
  - 多线程
  - Java
  - 锁机制
---

#### 实现方式分类
##### 1）内置锁（Intrinsic Lock）
通过`synchronized`关键字实现，由JVM自动管理锁的获取与释放，无需手动控制
##### 2）显式锁（Explicit Lock）
通过`java.util.concurrent.locks`包中的类（如`ReentrantLock`）实现，需手动调用`lock()`和`unlock()`方法
#### 按线程对于资源的访问态度

##### 1）悲观锁
假设并发冲突必然发生，直接加锁保护资源（如`synchronized`和`ReentrantLock`）
##### 2）乐观锁
假设无冲突，通过版本号或CAS机制实现（如`AtomicInteger`类）

#### 按锁的公平性

##### 1）公平锁
遵循先申请先获取的规则（如`ReentrantLock(true)`）
##### 2）非公平锁
允许线程插队竞争（如`synchronized`和默认的`ReentrantLock`）

#### 按锁的可重入性

##### 1)可重入锁
同一线程可多次获取同一把锁（如`synchronized`和`ReentrantLock`）
##### 2)不可重入锁
线程仅能获取一次锁（Java中无原生实现，需手动设计）

#### 按锁的共享性

##### 1)独占锁（排他锁）
仅允许一个线程访问资源（如`synchronized`和`ReentrantLock`）
##### 2)共享锁
允许多线程并发读资源（如`ReentrantReadWriteLock.ReadLock`）

#### 按锁的竞争优化策略

##### 1)偏向锁/轻量级锁/重量级锁
JVM对`synchronized`的优化状态，根据竞争强度动态升级
##### 2)自旋锁
通过循环尝试避免线程阻塞（如基于CAS的自旋实现）

#### 特殊锁机制补充

##### 1)分段锁
如`ConcurrentHashMap`的分段锁设计，降低锁粒度
##### 2)双重检查锁
需配合`volatile`使用，避免指令重排序问题