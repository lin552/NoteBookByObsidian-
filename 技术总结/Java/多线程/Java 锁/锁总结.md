---
创建时间: 2025-04-18 11:22:56
作者: wangxiaoming
tags:
  - 锁
  - Lock
  - synchronzied
  - StampeLock
  - ReentrantReadWriteLock
  - ReetrantLock
---
#### 一、主流锁机制总结

##### 1）`synchronized` 内置锁
- ​**特点**​：
    - ​**自动释放**​：通过 `JVM` 隐式管理锁的获取与释放，无需手动操作
    - ​**可重入性**​：同一线程可重复获取同一把锁（基于对象头的计数器实现）
    - ​**非公平性**​：默认采用非公平策略，允许插队，提高吞吐量但可能导致饥饿
- ​**适用场景**​：
    - 简单的线程同步需求（如单例模式、计数器等）。
    - 低竞争场景，代码简洁性优先于灵活性。
- ​**缺点**​：功能有限，不支持中断、超时或公平锁策略
##### 2）`ReetrantLock` 可重入锁
- ​**特点**​：
    - ​**显式控制**​：需手动调用 `lock()` 和 `unlock()`，灵活性高
    - ​**公平性可选**​：支持公平锁（按顺序获取）和非公平锁（默认）
    - ​**高级功能**​：支持可中断锁（`lockInterruptibly()`）、超时获取（`tryLock()`）
    - ​**条件变量**​：通过 `Condition` 实现多线程协作（替代 `wait()/notify()`）
- ​**适用场景**​：
    - 复杂同步逻辑（如需要中断或超时控制的场景）。
    - 高竞争环境下的公平性需求（如任务调度）。
- ​**缺点**​：需手动管理锁释放，易因遗漏 `unlock()` 导致死锁

##### 3）`ReetrantReadWriteLock` 读写锁
- ​**特点**​：
    - ​**读写分离**​：读锁共享（允许多线程并发读），写锁独占（互斥）
    - ​**锁降级**​：写锁可降级为读锁，保证数据可见性（如先写后读同一数据）
    - ​**公平性可选**​：与 `ReentrantLock` 类似，支持公平/非公平模式
- ​**适用场景**​：
    - 读多写少的场景（如缓存系统、配置管理）
    - 需要保证读写数据一致性的场景。
- ​**缺点**​：写锁饥饿问题（长时间读操作阻塞写线程）

##### 4）`StampedLock` 邮戳锁（Java 8+）
- ​**特点**​：
    - ​**乐观读机制**​：读取时不加锁，通过版本号（`stamp`）验证数据一致性
    - ​**模式切换**​：支持悲观读、写锁及乐观读升级为写锁
    - ​**高性能**​：在读多写少的场景下，吞吐量优于 `ReentrantReadWriteLock`
- ​**适用场景**​：
    - 高并发读操作（如金融行情数据读取）
    - 需要低锁开销且容忍短暂数据不一致的场景。
- ​**缺点**​：API 复杂，乐观读需结合循环验证，易出错

#### 二、锁选择的最佳实践
1. ​**简单场景优先**​：优先使用 `synchronized`，避免过度设计
2. ​**读写分离优化**​：读多写少时选择 `ReentrantReadWriteLock` 或 `StampedLock`
3. ​**高并发读场景**​：`StampedLock` 的乐观读可显著提升性能，但需处理版本验证
4. ​**公平性与中断需求**​：需要精确控制线程调度时，使用 `ReentrantLock`
5. ​**避免锁饥饿**​：读写锁中可通过公平策略缓解，但会牺牲吞吐量



