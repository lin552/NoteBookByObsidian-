---
创建时间: 2025-04-12 17:39:17
作者: wangxiaoming
tags:
  - synchronzied
---
#### 一、synchronized 原理
synchronized 是 Java 中基于 ​**Monitor 机制**​ 实现的互斥锁，其核心原理如下
1. ​**对象头与 Monitor**​：每个 Java 对象头中的 ​**Mark Word**​ 存储锁状态（无锁、偏向锁、轻量级锁、重量级锁），并关联一个 Monitor（监视器）
2. **锁竞争与阻塞**​：线程进入 synchronized 代码块时尝试获取对象锁（通过 `monitorenter` 指令），若锁被占用则阻塞；退出时通过 `monitorexit` 释放锁
3.  ​**锁升级机制**​（`JDK1.6+优化`）：
    - ​**偏向锁**​：单线程重复访问时无需竞争锁
    - ​**轻量级锁**​：多线程交替访问时通过 `CAS` 自旋尝试获取锁
    - ​**重量级锁**​：竞争激烈时转为操作系统级互斥锁，线程挂起
#### 二、使用方式与示例
`synchronized`的三种主要用法
##### 1）修饰实例方法：
锁对象为当前实例（this），每个实例独立拥有一把锁
```java
public synchronized void add() { count++;}
```
##### 2）修饰静态方法：
锁对象为类的Class对象（全局唯一）
```java
public static synchronized void add(){ count++; }
```
##### 3）修饰代码块：
可指定任意对象作为锁
```java
public void method(){
    synchronized (lockObject){
        //临界区代码
    }
}
```

##### 4）结合`wait()/notify()`机制
生产者消费者模型中，条件不足时让生产者或是消费者线程等待（使用`wait()`方法且释放锁），条件符合则通过(`notify()`或`notifyAll()`唤醒其他线程执行）

`notify` 和 `notifyAll` 的利弊对比如下：
######  ​`notify()`​
- ​**优势**​：
    - ​**开销低**​：仅唤醒一个线程，减少上下文切换和锁竞争的开销
    - ​**效率高**​：适用于单一条件场景（如单生产者-消费者模型），避免无效唤醒
- ​**风险**​：
    - ​**死锁或饥饿**​：若唤醒的线程无法处理条件变更（如资源未就绪），可能导致其他线程无限等待
    - ​**不确定性**​：随机唤醒机制可能遗漏关键线程，导致逻辑错误
###### ​`notifyAll()`​
- ​**优势**​：
    - ​**安全性高**​：唤醒所有线程，确保条件变更被所有等待线程感知，避免遗漏
    - ​**兼容性广**​：适用于多条件协作场景（如多个生产者或消费者竞争不同资源）
- ​**缺点**​：
    - ​**性能开销大**​：唤醒所有线程会增加锁竞争和上下文切换，尤其在大量线程等待时可能显著降低性能
    - ​**资源浪费**​：多数被唤醒的线程可能因条件不满足重新进入等待，造成无效调度

#### 三、使用注意事项
##### 1）死锁风险
避免嵌套获取多把锁（如线程 A 持有锁 1 请求锁 2，线程 B 持有锁 2 请求锁 1）
```java
//错误示例：嵌套锁导致死锁
synchronized(lockA){
   synchronized(lockB){
   }
}
```
##### 2）性能问题
过度同步可能导致线程阻塞，可通过缩小同步范围或使用并发工具优化
##### 3）**锁对象选择**
静态方法锁类对象，实例方法锁当前实例，代码块需明确锁对象

#### 四、优化策略
1. ​**减少锁粒度**​：仅同步必要代码块（如使用局部锁对象而非整个方法）
2. ​**读写分离**​：读多写少场景用 `ReadWriteLock` 替代独占锁
3. ​**无锁编程**​：使用 `AtomicInteger` 等原子类实现无锁操作
4. ​**锁消除与粗化**​：`JVM` 自动优化（如消除无竞争的锁、合并连续锁操作）

#### 五、 **面试高频考点**
1. ​**锁升级过程**​（无锁→偏向锁→轻量级锁→重量级锁）
2. ​`synchronized vs ReentrantLock`**​：可重入性、公平性、中断支持等区别
3. ​`Monitor` 工作机制：对象头、`monitorenter/monitorexit` 指令
4. ​**死锁场景与排查**​：如何通过线程转储（`jstack`）分析死锁
5. ​**性能优化实践**​：锁粗化、自旋锁适用场景
