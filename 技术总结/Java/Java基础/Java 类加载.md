---
创建时间: 2025-04-20 13:34:19
作者: wangxiaoming
tags:
  - 类加载
---
#### 一、重要机制与核心原理
1. ​**类加载阶段**​
    - ​**加载（Loading）​**​：通过类加载器将`.class`文件二进制数据读入内存，并在堆中生成`Class`对象（方法区入口）
    - ​**验证（Verification）​**​：检查字节码是否符合`JVM`规范（如文件格式、元数据、字节码逻辑）
    - ​**准备（Preparation）​**​：为静态变量分配内存并赋默认值（如`int`初始化为0），若为`final static`则直接赋值
    - ​**解析（Resolution）​**​：将符号引用转为直接引用（如方法地址）
    - ​**初始化（Initialization）​**​：执行`<clinit>`方法，完成静态变量赋值和静态代码块逻辑
2. ​**双亲委派模型**​
    - ​**机制**​：类加载请求优先委托父加载器处理，依次为：​**Bootstrap → Extension → Application → 自定义加载器**​
    - ​**优点**​：避免重复加载，确保核心类安全（如`java.lang.String`仅由Bootstrap加载）
    - ​**破坏场景**​：Tomcat隔离Web应用、`OSGi`模块化、热部署等需自定义加载器时
3. ​**类生命周期**​  
    包括加载、使用、卸载（需满足条件：无实例、`Class`对象无引用、加载器被回收）
#### 二、常见类加载器
1. ​`Bootstrap ClassLoader​`
    - ​**职责**​：加载`JRE/lib`下的核心类（如`rt.jar`），由C++实现，无Java对象
2. ​`Extension ClassLoader`​
    - ​**职责**​：加载`JRE/lib/ext`或`java.ext.dirs`指定的扩展类（如`javax.*`）
3. ​`Application ClassLoader`​
    - ​**职责**​：加载`CLASSPATH`路径下的应用类，默认程序入口
4. ​**自定义加载器**​
    - ​**场景**​：热部署、插件隔离（如Tomcat）、加密类加载
    - ​**实现**​：继承`ClassLoader`，重写`findClass()`方法
#### 三、面试考察点
1. ​**类加载顺序**​
    - ​**静态优先**​：父类静态代码块 → 子类静态代码块 → 父类非静态代码块 → 父类构造器 → 子类非静态代码块 → 子类构造器
    - ​**示例**​：若子类调用父类静态变量，仅触发父类初始化（如`Son.factor`触发父类静态块）
2. ​**双亲委派流程**​
    - 问题：如何自定义加载器绕过双亲委派？答案：重写`loadClass()`方法
3. ​**类初始化触发条件**​
    - `new`、`static`方法调用、反射调用等
4. ​`final static`与`static`变量区别​
    - `final static`在准备阶段赋值，`static`在初始化阶段赋值
#### 四、日常使用注意事项
1. ​**避免内存泄漏**​
    - 自定义类加载器长期持有引用会导致类无法卸载，需及时置空加载器或使用弱引用
2. ​**线程安全**​
    - 多线程加载同一类可能重复初始化，需同步控制（如`synchronized`块）
3. ​**资源隔离**​
    - 插件化系统中，不同模块使用独立加载器，避免类冲突（如Tomcat的Web应用隔离）
4. ​**热部署实现**​
    - 每次修改后创建新加载器实例加载类，旧实例随`GC`回收
5. ​**谨慎破坏双亲委派**​
    - 仅在必要时（如动态加载外部代码）破坏，否则可能引发安全漏洞
#### 五、典型应用场景
- ​**框架开发**​：Spring的`@Autowired`依赖注入通过反射实现
- ​**热加载**​：IDE调试时动态替换修改后的类
- ​**加密保护**​：自定义加载器解密网络传输的加密字节码
- ​**多版本共存**​：通过不同加载器隔离同一类的不同版本（如`JDBC`驱动兼容）
