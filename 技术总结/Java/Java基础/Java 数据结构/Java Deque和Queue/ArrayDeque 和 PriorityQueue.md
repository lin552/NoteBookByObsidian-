---
创建时间: 2025-05-13 12:05:48
作者: wangxiaoming
tags:
  - Deque
  - Queue
---

#### 一、`ArrayDeque`​

##### ​**1. 定义与原理**​

- ​**定义**​：`ArrayDeque` 是基于循环数组实现的双端队列（`Deque`），支持在队列的头部和尾部高效插入/删除元素，同时也可作为栈（LIFO）使用
- ​**原理**​：
    - ​**底层结构**​：使用动态数组 `elements`，通过 `head` 和 `tail` 指针标记队列的头部和尾部。`tail` 指向下一个可插入的位置，而非尾部元素的实际索引
    - ​**循环数组**​：通过取模运算（`(head - 1) & (elements.length - 1)`）实现循环，避免频繁移动元素。
    - ​**扩容机制**​：当数组满时，容量扩容为原来的两倍，并分两次复制原数组元素到新数组中（先右后左）
##### ​**2. 使用方法**​
- ​**核心操作**​：
    - ​**双端队列**​：`addFirst(e)/addLast(e)`、`removeFirst()/removeLast()`、`peekFirst()/peekLast()`。
    - ​**栈操作**​：`push(e)`（压栈）、`pop(e)`（弹栈）。
    - ​**队列操作**​：`offer(e)`（入队）、`poll()`（出队）
```java
ArrayDeque<Integer> deque = new ArrayDeque<>();
deque.addFirst(1); //[1]
deque.addLast(2); // [1,2]
deque.pollFirst(); //返回1，队列变为[2]
```
##### **3. 注意事项**​
- ​**禁止插入 `null`**​：`ArrayDeque` 不允许插入 `null` 元素，否则抛出 `NullPointerException`
- ​**线程不安全**​：需自行处理并发问题（如使用 `Collections.synchronizedDeque()` 包装）。
- ​**扩容开销**​：扩容时需复制数组，频繁扩容影响性能，建议预分配容量。
##### ​**4. 优化建议**​
- ​**预分配容量**​：根据预估元素数量初始化数组，减少扩容次数。
- ​**避免中间操作**​：频繁在中间插入/删除元素时，性能低于 `LinkedList`。
##### ​**5. 适用场景**​
- ​**高效双端操作**​：如任务调度、滑动窗口算法。
- ​**栈替代**​：比 `Stack` 类性能更优。
- ​**队列替代**​：比 `LinkedList` 内存更紧凑，操作更快

#### 二、`PriorityQueue`
##### **1. 定义与原理**​
- ​**定义**​：`PriorityQueue` 是基于优先级堆（小顶堆）的无界队列，元素按优先级顺序出队，默认最小元素优先
- ​**原理**​：
    - ​**底层结构**​：使用数组模拟完全二叉树，父节点小于等于子节点（小顶堆）。
    - ​**堆调整**​：插入时通过 `siftUp()` 上浮调整堆结构；删除堆顶时通过 `siftDown()` 下沉调整
    - ​**排序规则**​：默认自然顺序（需元素实现 `Comparable`），或通过 `Comparator` 自定义
##### ​**2. 使用方法**​
- ​**核心操作**​：
    - ​**插入**​：`offer(e)`（返回 `boolean`）或 `add(e)`（抛出异常）。
    - ​**删除**​：`poll()`（删除堆顶元素）或 `remove(Object o)`。
    - ​**查看堆顶**​：`peek()`（不删除元素）
```java
PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());
pq.offer(3); //堆:[3]
pq.offer(1); //堆：[1,3]
pq.poll();   //返回1，堆变成[3]
```
##### ​**3. 注意事项**​
- ​**不支持 `null`**​：插入 `null` 会抛出 `NullPointerException`。
- ​**非线程安全**​：需外部同步（如使用 `PriorityBlockingQueue`）。
- ​**元素需可比较**​：自定义对象需实现 `Comparable` 或提供 `Comparator`。
##### ​**4. 优化建议**​
- ​**预分配容量**​：通过构造函数指定初始容量，减少扩容次数。
- ​**自定义比较器**​：避免默认排序规则导致的性能问题（如频繁对象比较）。
- ​**避免频繁插入**​：若需频繁插入/删除，考虑其他结构（如 `TreeSet`）。
##### ​**5. 适用场景**​
- ​**优先级调度**​：如任务队列（VIP 用户优先处理）、Dijkstra 最短路径算法。
- ​**Top K 问题**​：快速获取最大/最小元素（结合堆大小控制）

#### 三、对比与总结
|**特性**​|​**ArrayDeque**​|​**PriorityQueue**​|
|---|---|---|
|​**底层结构**​|循环数组|二叉堆（数组模拟）|
|​**操作特性**​|双端/栈操作，FIFO 或 LIFO|按优先级出队，动态调整顺序|
|​**时间复杂度**​|均摊 O(1)|插入/删除 O(log n)|
|​**线程安全**​|非线程安全|非线程安全|
|​**适用场景**​|高效双端队列、栈|优先级调度、Top K 问题|
#### 四、综合建议
- ​**选择 `ArrayDeque`**​：当需要高效的双端操作或栈功能时，优先使用。
- ​**选择 `PriorityQueue`**​：当元素需按优先级处理时（如实时任务调度）。
- ​**线程安全**​：多线程环境下，使用 `ConcurrentLinkedDeque`（替代 `ArrayDeque`）或 `PriorityBlockingQueue`（替代 `PriorityQueue`）。